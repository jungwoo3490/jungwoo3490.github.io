{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/GraphQL/","result":{"data":{"markdownRemark":{"html":"<p>요즘 개발자들 입에 자주 오르내리고, 채용 공고들을 보면 우대사항에서 심심치 않게 볼 수 있는 기술이 있어요. 바로 GraphQL입니다.</p>\n<p>GraphQL은 대체 뭘 하는 친구일까요??</p>\n<h2>GraphQL이란</h2>\n<p>GraphQL이란 페이스북에서 개발한 <strong>쿼리 언어</strong>에요. 그렇다면 쿼리 언어란 무엇일까요??</p>\n<p>Query의 사전적 의미는 <strong>'질의'</strong> 라는 의미에요.\n따라서 Query Language는 질의를 하기 위한 언어, 즉 데이터 요청을 하기 위해 특화된 언어라는 뜻입니다.</p>\n<p>Query Language의 대표적인 예시로 <strong>SQL(Structed Query Language)</strong> 이 있어요.<br/>\nSQL은 데이터베이스에 저장된 데이터를 가져오기 위해 데이터베이스에 질의하는 언어죠.</p>\n<p>GraphQL은 SQL과 같은 쿼리 언어이지만, 언어적 구조 자체가 매우 달라요.<br/>\n그 이유는 각자 질의의 목적 자체가 다르기 때문이에요.</p>\n<p>SQL은 데이터베이스에 저장된 데이터들을 효율적으로 가져오는 데 목적을 둔 언어에요.<br/>\n이와 반대로 GraphQL은 웹 클라이언트 측에서 서버로부터 데이터를 효율적으로 가져오는 데 목적을 둔 언어에요.</p>\n<p>보통 질의 언어를 질의하는 쪽에서 작성하는데, 그래서 SQL은 주로 백엔드 시스템에서 작성하게 되고 GraphQL는 주로 클라이언트 시스템에서 작성하게 돼요.</p>\n<hr>\n<h2>GraphQL 등장 배경</h2>\n<p>앞서 말했듯이 GraphQL은 FaceBook에서 개발한 쿼리 언어에요. REST API 방식이 현재까지도 많이 쓰이고 있는데, FaceBook은 GraphQL을 왜 만들었을까요??</p>\n<p>2012년 당시 FaceBook은 Restful한 서버와 FQL(FaceBook의 SQL) 데이터 테이블을 사용하고 있었어요.<br/>\n하지만 앱 충돌이 많이 발생했고, 성능도 좋지 못했어요.</p>\n<p>FaceBook은 데이터를 클라이언트로 전송하는 방식을 개선해야 한다는 것을 깨달았고, GraphQL을 개발하기 시작했어요.</p>\n<p>기존 REST 방식은 2가지 큰 단점이 존재했어요.</p>\n<p>• <strong>Over-Fetching</strong>: 클라이언트에서 사용하려고 데이터를 요청했는데, 데이터를 너무 많이 받아온 경우에요. 쓸모없는 데이터를 보내 통신을 무겁게 하고 프론트측 데이터에 혼동을 줄 가능성이 있어요.</p>\n<p>• <strong>Under-Fetching</strong>: 데이터를 요청하고 나서 원하는 데이터를 완전히 받아오지 못해 추가적인 데이터를 또 요청해야 하는 경우를 의미해요. 하나의 EndPoint로 데이터가 충족되지 않아 API를 두번 호출해야 하는 상황이 되고, 이렇게 되면 사용자에게 느린 서비스를 제공할 수 밖에 없게 돼요.</p>\n<p>GraphQL은 이 2가지 문제를 해결하고자 했어요. GraphQL을 사용하면 정확히 내가 원하는 데이터만 받을 수 있어 Over-Fetching 문제를 해결할 수 있고, 단 하나의 request만으로 필요한 모든 데이터를 받을 수 있어 Under-Fetching 문제를 해결할 수 있어요.</p>\n<hr>\n<h2>GraphQL 원리</h2>\n<p>서버에서는 클라이언트가 GraphQL 방식으로 요청할 수 있는 데이터의 타입들과 각 타입에 대해 요청할 수 있는 필드들을 정의하여 타입 시스템을 구축하고, 각 타입의 각 필드에 대한 요청을 해석 및 처리하는 로직을 Resolver 함수들로 구현해요.</p>\n<p>이후 클라이언트가 GraphQL 쿼리를 보내면, 서버는 미리 정의해둔 타입 시스템에 따라 해당 쿼리를 검증(Validation)하고, 문제가 없다면 미리 구현해둔 Resolver 함수들을 호출하여 해당 쿼리를 실행(Execution)한 결과를 클라이언트에게 응답해요.</p>\n<p><img src=\"https://velog.velcdn.com/images/jungwoo3490/post/443eb87b-0567-4cb6-a81b-52165fd07ee3/image.png\" alt=\"\"></p>\n<p>이러한 방식을 사용하면 여러번 네트워크 호출을 할 필요 없이, 한 번의 네트워크 호출로 요청을 처리할 수 있게 돼요.</p>\n<h3>🍀 Resolver 함수</h3>\n<p>GraphQL에서는 데이터를 가져오는 구체적인 과정을 직접 구현해야 해요.</p>\n<p>GraphQL 쿼리문 파싱은 대부분의 GraphQL 라이브러리에서 처리를 하지만, GraphQL에서 데이터를 가져오는 구체적인 과정은 Resolver 함수가 담당하고, 이를 직접 구현해야 해요.</p>\n<p>개발자는 Resolver 함수를 직접 구현해야하는 부담은 있지만, 이를 통해서 데이터 source의 종류에 상관없이 구현이 가능하게 돼요.</p>\n<hr>\n<h2>쿼리 &#x26; 뮤테이션</h2>\n<h3>🍀 필드</h3>\n<p>GraphQL은 객체에 대한 특정 필드를 요청하는 것이 무척 간단해요</p>\n<p>다음은 hero의 이름에 대해 질의하는 쿼리입니다.</p>\n<p><img src=\"https://velog.velcdn.com/images/jungwoo3490/post/2004bfad-8ce1-462b-a211-98852192114f/image.png\" alt=\"\"></p>\n<p>보다시피 쿼리의 요청 형식과 쿼리 결과 형식이 동일한 형태인 것을 확인할 수 있어요. 이렇게 항상 기대한 결과를 얻을 수 있다는 점이 GraphQL의 장점이에요.</p>\n<p>또 GraphQL 쿼리는 연관된 객체와 필드를 탐색 할 수 있으므로 클라이언트는 여러번 요청을 수행하는 대신 한번의 요청으로 많은 데이터를 가져올 수 있다는 장점도 있어요.</p>\n<p><img src=\"https://velog.velcdn.com/images/jungwoo3490/post/21075556-ca1b-4765-945c-a42950d5a041/image.png\" alt=\"\"></p>\n<h3>🍀 인자</h3>\n<p>GraphQL은 다음과 같이 필드에 인자를 전달할 수 있는 기능을 제공해요.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.085889570552148%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAh0lEQVR42m1P7Q7CIBDb+z+mxkSToUKGcF/Uu+gPpjvSNDlKWxYRQamE3hloDHUMP7+jrqNcIaIY4/8+JvaLEy7rhvM1g5+Ee2kgf7QTfjmtBadbhtSO9mhoqcKiyGzI7K3UYOa9HBp80CB2nQXJA19dPNiQNw822xuqzl/4mB2BiBDao6AZb1rtO5ZjDOtVAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"인자 예시 1\"\n        title=\"\"\n        src=\"/static/d213cb27dfc7d6b620dafb54f46d7570/a6d36/image.png\"\n        srcset=\"/static/d213cb27dfc7d6b620dafb54f46d7570/222b7/image.png 163w,\n/static/d213cb27dfc7d6b620dafb54f46d7570/ff46a/image.png 325w,\n/static/d213cb27dfc7d6b620dafb54f46d7570/a6d36/image.png 650w,\n/static/d213cb27dfc7d6b620dafb54f46d7570/e548f/image.png 975w,\n/static/d213cb27dfc7d6b620dafb54f46d7570/3c492/image.png 1300w,\n/static/d213cb27dfc7d6b620dafb54f46d7570/2a333/image.png 1484w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>REST 시스템에서는 요청에 쿼리 파라미터와 URL 세그먼트같은 단일 인자들만 전달할 수 있었어요. 하지만 GraphQL에서는 위 예제에서 보다시피 모든 필드와 중첩된 객체가 인자를 가질 수 있으므로 기존에 요청을 여러번 보내야 했던 문제를 완벽히 대체할 수 있어요.</p>\n<p>인자로는 다양한 타입을 전달할 수 있어요. GraphQL은 기본적으로 기본 타입을 제공하지만, GraphQL 서버는 데이터를 직렬화 할 수 있는 한 직접 커스텀 타입을 선언할 수도 있습니다.</p>\n<h3>🍀 별칭</h3>\n<p>결과 객체 필드가 ​​쿼리의 필드 이름과 일치하지만 인자는 그렇지 않으므로 다른 인자를 사용하여 같은 필드를 직접 쿼리할 수는 없어요. 그래서 필드의 결과를 원하는 이름으로 바꿀 수 있는 기능을 제공하는데, 이를 별칭이라고 해요.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.380368098159508%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsklEQVR42oWQ6wrCMAyF9/7PqYLo2OzWNs2lx7RzP+YETwmBcvLlMjALQiyImUGiyJ4lKRZSzIlhZqj+hAo4JBT3q9X+11RrPcQgqrg+V0wLITIjhgIK3IGRuJu6HDw+Ai7jgrxkyCtBpwQjwa4ObBPcHDi3KQt3GPmEwY0i8jFuBdNKuE8RkgvMN6li3qgega1I1fBXbo4OalD15ubnOFscqL4yUE+3+A7m7Z69cI8fvjeMBonPZjaUjAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"별칭 예시 1\"\n        title=\"\"\n        src=\"/static/b8003d3378e0ff3195f6be0087d57a24/a6d36/image-1.png\"\n        srcset=\"/static/b8003d3378e0ff3195f6be0087d57a24/222b7/image-1.png 163w,\n/static/b8003d3378e0ff3195f6be0087d57a24/ff46a/image-1.png 325w,\n/static/b8003d3378e0ff3195f6be0087d57a24/a6d36/image-1.png 650w,\n/static/b8003d3378e0ff3195f6be0087d57a24/e548f/image-1.png 975w,\n/static/b8003d3378e0ff3195f6be0087d57a24/3c492/image-1.png 1300w,\n/static/b8003d3378e0ff3195f6be0087d57a24/0d390/image-1.png 1472w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위 예제에서 두 hero 필드에서 다른 인자를 사용하여 충돌이 일어나지만, 서로 다른 이름의 별칭을 지정해서 하나의 요청에서 두 가지 결과를 모두 얻을 수 있어요.</p>\n<h3>🍀 작업 타입</h3>\n<p>위 예시들에서는 query 키워드와 query 이름을 모두 생략한 단축 문법을 사용했어요. 하지만 실제 애플리케이션에서는 코드를 헷갈리지 않게 하기 위해 키워드와 이름을 생략하지 않는 것이 좋아요.<br/>\n공식문서에서도 query 키워드와 query 이름을 생략하지 않는 것을 권장해요.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.380368098159508%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAoUlEQVR42oVQ7Q6DIBDz/V9zP5ZpdIICHvfRgQvOJS4raQihtPS6MD/h+gk8Okjl5JGXAKvLPuSNQC5ARNBwvm/squDWezymFVCtqjdP2E9qGAaP+7iAfYKmjCt0qoK4ZSw/BO0nFZkV/RwRAsGIYSywLHvYYUhEx4N/qLpYgmMuZmUXl8AlwEpQq7JXvprFFbWMJCQqjRgai+G6wdS+5v0CXXGKeKPgMeoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"작업 타입 예시 1\"\n        title=\"\"\n        src=\"/static/f6db2f823f77225353560f417ccc5847/a6d36/image-2.png\"\n        srcset=\"/static/f6db2f823f77225353560f417ccc5847/222b7/image-2.png 163w,\n/static/f6db2f823f77225353560f417ccc5847/ff46a/image-2.png 325w,\n/static/f6db2f823f77225353560f417ccc5847/a6d36/image-2.png 650w,\n/static/f6db2f823f77225353560f417ccc5847/e548f/image-2.png 975w,\n/static/f6db2f823f77225353560f417ccc5847/3c492/image-2.png 1300w,\n/static/f6db2f823f77225353560f417ccc5847/a2792/image-2.png 1462w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위 예제에서 'query' 부분을 <strong>작업 타입</strong> 이라고 하고, 'HeroNameAndFriends' 부분을 <strong>작업 이름</strong> 이라고 합니다.</p>\n<p>작업 타입에는 <code>query</code>, <code>mutation</code>, <code>subscription</code>이 있어요.</p>\n<p>작업 이름은 명시적으로 적어주어야 서버의 로깅 및 디버깅에 용이해요.</p>\n<p>⭐️ <strong>query</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.380368098159508%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABJElEQVR42m2QT07CYBTEewyOQCIbrgBLVhyIo2ACCSSyQ9TuhRDDThZaKCBikWKBFgul/+jPr18MceEkk8zivXkzT0FgMBjQ6XRSSZIk/EUSn4nev3GbYw43Y6KFC5sNyccC1ibm0qDRbFKtVtE0DSVdqlQqFItFaRDHMY7j4HnexfzQ0gk1m1B3OLYmhJaFORwKY4unXo+rXI5MJkO9XkfRdZ1CoUA2m0VVVWzbZiiGZ7MZ08mUO/WeU0PHf7YIXnfsr1/4tL7Q3uaY2y2P3a4Mk8/nabfbKP1+n3K5TKlUolaryURpQt/3JVfLFfF0j3c75/SwIBQ6PB5Zj0YE4rhhGDJIykvltGYURfyL35fuzR3fghLnM+InEATEQruuK5n6/ADIZl27W6LZvwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"query 작업타입\"\n        title=\"\"\n        src=\"/static/003fd5d348c10d41df3cd70813a8bf6d/a6d36/image-3.png\"\n        srcset=\"/static/003fd5d348c10d41df3cd70813a8bf6d/222b7/image-3.png 163w,\n/static/003fd5d348c10d41df3cd70813a8bf6d/ff46a/image-3.png 325w,\n/static/003fd5d348c10d41df3cd70813a8bf6d/a6d36/image-3.png 650w,\n/static/003fd5d348c10d41df3cd70813a8bf6d/e548f/image-3.png 975w,\n/static/003fd5d348c10d41df3cd70813a8bf6d/3c492/image-3.png 1300w,\n/static/003fd5d348c10d41df3cd70813a8bf6d/c6f3b/image-3.png 2950w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>query는 <strong>읽기 전용</strong> 으로 데이터를 가져오기 위한 작업타입이에요. 데이터의 변화 없이 단순 조회가 필요할 때 사용해요.</p>\n<p>⭐️ <strong>mutation</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.380368098159508%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKklEQVR42m2QS07CYBRGuww2QMICWACBDTBjOeyDiSHpAHVCxGpgQoIjhqgk0kIlCkjBWvuAvnv8AaMx8Utuch+5j3MlhIbDIe12++CSZRl/FGdEuo0rT/AuNOJnB3yfzHUhDFktlzSbTRqNBqqqIh166vU6lUrl1B/HmKaJ67g/w71zjUj7JFYtdpczIsfhTZ3AfsfdYEChUCCXy9FqtZA0TaNUKpHP51EUBcuyGI1G6DOdqahd3yj48pTgfks4NrHPxqyMNU+6jrF9p9/vUy6XKRaLdDodpANurVajWq0iy/LxItu2CYKAIAzYrA0SgelfzQluX4jnLtF+j/H4QCSwXxcLut0uvV7vFzlJkiPqv/p+qb3+wN5YpyAVSbGMNBVuhud5R0tF/AU5wV5h8qXBBAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mutation 작업타입\"\n        title=\"\"\n        src=\"/static/87e7dc4190b6b0b1f8657f34fb64d520/a6d36/image-4.png\"\n        srcset=\"/static/87e7dc4190b6b0b1f8657f34fb64d520/222b7/image-4.png 163w,\n/static/87e7dc4190b6b0b1f8657f34fb64d520/ff46a/image-4.png 325w,\n/static/87e7dc4190b6b0b1f8657f34fb64d520/a6d36/image-4.png 650w,\n/static/87e7dc4190b6b0b1f8657f34fb64d520/e548f/image-4.png 975w,\n/static/87e7dc4190b6b0b1f8657f34fb64d520/3c492/image-4.png 1300w,\n/static/87e7dc4190b6b0b1f8657f34fb64d520/30c0b/image-4.png 2956w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>mutation은 <strong>데이터를 변경</strong> 후 가져오기 위한 작업타입이에요. 요청을 통해 데이터를 변화시켜야 할 경우 사용해요.</p>\n<p>⭐️ <strong>subscription</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.380368098159508%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABQElEQVR42kWQwU7CUBBF+Qz9APkDtixYsGfDx/Ab7iSaIAmJIcFIYgCLWwi6QU0jLZU2kYaqlZa2Wmixx9cudJKbuXmZuXlncogaj8d0u93UkiTJX09dEv8QLTb4jRlBWyNeuBAEJL4P4TdLw+C82aRer6NpGrl0uVarUS6Xs6A4jrFtO1O03xNuI4KLObHmEs0cvtrCuw7WfJ4F3w4GHOXzHB4c0Ol0yCmKQrFYJC8ee70ejuOg6zoP0ymX1zcYby6bU5mdbLN7tPEazyytFTNVxbQspOGQUqlEoVBgKHxuNBpRrVapVCq0Wi08zxOBBneTCccnZ6w+PELVIbwy2A5eifQNpmmiKiovAlGWZSRJot/v/yPvBVqKmpYvbrNer8XSkvvpE35Edkt39Yn37mQzrutiid+lCsNQkAeZ0pxfJWlZWtylyOsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"subscription 작업타입\"\n        title=\"\"\n        src=\"/static/fbc1c8eef8a8fe73d6ab64427684e967/a6d36/image-5.png\"\n        srcset=\"/static/fbc1c8eef8a8fe73d6ab64427684e967/222b7/image-5.png 163w,\n/static/fbc1c8eef8a8fe73d6ab64427684e967/ff46a/image-5.png 325w,\n/static/fbc1c8eef8a8fe73d6ab64427684e967/a6d36/image-5.png 650w,\n/static/fbc1c8eef8a8fe73d6ab64427684e967/e548f/image-5.png 975w,\n/static/fbc1c8eef8a8fe73d6ab64427684e967/3c492/image-5.png 1300w,\n/static/fbc1c8eef8a8fe73d6ab64427684e967/006be/image-5.png 2959w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>subscription는 <strong>실시간으로 변경된 데이터</strong> 를 가져오기 위한 작업타입이에요. 웹 소켓을 열어두고 데이터 업데이트 시 알려주는 방식으로 구현되어 있어요.</p>\n<h3>🍀 변수</h3>\n<p>위 예제들에서는 모든 인자를 쿼리 문자열 안에 작성했어요. 하지만 대부분의 응용프로그램에서 필드에 대한 인자는 동적인 경우가 많아요.</p>\n<p>클라이언트는 쿼리 문자열을 런타임에 동적으로 조작하고 GraphQL의 특정한 포맷으로 직렬화해야하기 때문에 동적 인자를 쿼리 문자열에 직접 전달하는 것은 좋은 방법이 아니에요.</p>\n<p>GraphQL은 동적 값을 쿼리에서 없애고, 이를 별도로 전달하는 방법을 제공한다. 이러한 값을 <strong>변수</strong> 라고 해요.</p>\n<p>⭐️ <strong>변수 사용법</strong></p>\n<p>1. 쿼리안의 정적 값을 <code>$variableName</code> 으로 변경<br/>\n2. <code>$variableName</code>을 쿼리에서 받는 변수로 선언<br/>\n3. 별도의 전송규약 변수에 <code>variableName: value</code> 전달<br/></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.19631901840491%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA80lEQVR42oVR7W7DIAzM+7/lFGlr2jQrJGDANjdDl6ytps3SiR8c92GGEgLidUH5+EQaZ8Tpgm06Y3YTfLyB6YpCM1gEmgqqKGqt6FMf8D2DquD94nEaHZIj+G2BXxfkkqFqj+2+VulkWlacjVuKCSeGEfA6g7ERzPnNiPoLYZ891TivOBnYR2gxM60dhyAzo+Go8Y9gtnS3kCFsK7CTrZV4+hFs8aXtx3bDwn1Xu8kj9vSN76IJZYasqYs+Vc45gVK02gEpEnKg/ugVzXQXpHIPUE20Znn+lOa+kceaHNQISuXPymxVW+WWUC2hONtlloP3Bc58Jj/6Z3djAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"변수 예시\"\n        title=\"\"\n        src=\"/static/3cc33b83bb30fc9c755b24a56e6871b1/a6d36/image-6.png\"\n        srcset=\"/static/3cc33b83bb30fc9c755b24a56e6871b1/222b7/image-6.png 163w,\n/static/3cc33b83bb30fc9c755b24a56e6871b1/ff46a/image-6.png 325w,\n/static/3cc33b83bb30fc9c755b24a56e6871b1/a6d36/image-6.png 650w,\n/static/3cc33b83bb30fc9c755b24a56e6871b1/e548f/image-6.png 975w,\n/static/3cc33b83bb30fc9c755b24a56e6871b1/3c492/image-6.png 1300w,\n/static/3cc33b83bb30fc9c755b24a56e6871b1/f2331/image-6.png 1427w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<hr>\n<h2>스키마 &#x26; 타입</h2>\n<h3>🍀 객체타입 &#x26; 필드</h3>\n<p>GraphQL 스키마의 가장 기본적인 구성 요소는 객체 타입이에요. 객체 타입은 서비스에서 가져올 수 있는 객체의 종류와 그 객체의 필드를 나타내요.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 405px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.263803680981596%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABW0lEQVR42nWS227iQAyGef/H6WWvlu1qUZceQbSQ3Z4INANJYBomk2Ry+OpELVK0rSXbo7H9j/17BoVz1EVBXYp3BdQ11lrSNKUqS5zEnOTkWdb5Uu6qqqJpGr6SgZMEu/aJRkPi4SnOf2Luefwc/mAymXIzmXFxec10esf5n0tslqOU6oC/BCykA3mOLI4IVgpf7VmFCYnJMMkWvZmR7Ncc9kuS+AFrdrQ1TVN3dYjvzj1AEVfV/FUJv+8Dxp7ikAoN+QarznCHJ3I9Rz+fEPpXH6X9kT8pOALWAvgQaO6XMY/BG7OXmGVoWLymLNYJNi/J8oLg8Rc2HGN3Hml4S7odEy/P2Gy3HffHkSsBvBOwkXTorffM/R3BzvCstFBwwEiycyWxWmCjKzL9jzSeYkXfNjdorTteB62JoghjTK/17+S7eG/k9ju0HXYci2m17jxH7RUeF/L/Ut4BHKRnICY/NkgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"객체타입 예시\"\n        title=\"\"\n        src=\"/static/c8031ed77a27f837d1788efa3b8ca0f0/1d180/image-7.png\"\n        srcset=\"/static/c8031ed77a27f837d1788efa3b8ca0f0/222b7/image-7.png 163w,\n/static/c8031ed77a27f837d1788efa3b8ca0f0/ff46a/image-7.png 325w,\n/static/c8031ed77a27f837d1788efa3b8ca0f0/1d180/image-7.png 405w\"\n        sizes=\"(max-width: 405px) 100vw, 405px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>✽ <code>Character</code> 부분은 GraphQL의 객체 타입을 의미해요. 객체 타입은 필드를 가지고 있는 타입을 의미해요. 스키마 대부분의 타입은 객체 타입이에요.</p>\n<p>✽ <code>name</code>과 <code>appearsIn</code> 부분은 <code>Character</code> 타입의 필드예요. 즉, <code>name</code>과 <code>appearsIn</code>은 GraphQL 쿼리의 <code>Character</code> 타입 어디에서나 사용할 수 있는 필드입니다.</p>\n<p>✽ <code>String</code>은 내장된 스칼라 타입 중 하나예요. 스칼라 타입이란, 하위 필드가 존재하지 않는 타입으로, 구체적인 데이터를 나타내는 타입이에요. GraphQL의 객체 타입은 이름과 필드를 가지지만, 특정 시점에서 모든 필드들은 구체적인 데이터로 해석되어야 해요. 즉, 쿼리의 끝을 나타내는 부분이 필요하고, 이것이 스칼라 타입의 역할입니다.</p>\n<p>✽ <code>String!</code>과 같이 필드 뒤에 !가 붙으면 해당 필드가 non-nullable임을 의미해요. non-nullable로 필드를 지정하면, 이 필드를 쿼리할 때 GraphQL 서비스가 항상 값을 반환하는 것을 보장해요.</p>\n<p>✽ <code>[Episode]!</code> 처럼 <a href=\"%EB%8C%80%EA%B4%84%ED%98%B8\"></a>로 감싸져 있으면 객체의 배열을 의미해요. 또 뒤에 !가 붙었기 때문에 non-nullable한 필드예요. 따라서 <code>appearIn</code> 필드를 쿼리할 때 항상 0개 이상의 아이템을 가진 배열을 보장하게 돼요.</p>\n<h3>🍀 인자</h3>\n<p>GraphQL 객체 타입의 모든 필드는 0개 이상의 인수를 가질 수 있어요.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.22085889570552%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA3ElEQVR42p2QwU7DMBBE8/8fh4SAckApbd3UbmI7cdLYcRP8sAKCihsdaWVpd/12NMVVHvGu46RqrG2pqgpjDCEEUkr/rkJtXml1Bu2fqMSWc21oGk2MEUh/6ku3gO/Oz7w4tp6DHlmmmjjsSMuFNFvm6LlHhah7Ht7OnGygMwesEWj5jO8ly3VgnlquvmaJjo/Zr86llCil6DqXDUzrfI5ddrxQ2CFQSse7ckjt2NcjjYsZNuLNhlE/ru/kyvyxwfUD27JECJHBKh8JTP0u77ys8OI3hzWcm0zu0ycGDtH8ZvwwgAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"객체타입 인자\"\n        title=\"\"\n        src=\"/static/41c5b22d737fa4ef02747faf65decc48/a6d36/image-9.png\"\n        srcset=\"/static/41c5b22d737fa4ef02747faf65decc48/222b7/image-9.png 163w,\n/static/41c5b22d737fa4ef02747faf65decc48/ff46a/image-9.png 325w,\n/static/41c5b22d737fa4ef02747faf65decc48/a6d36/image-9.png 650w,\n/static/41c5b22d737fa4ef02747faf65decc48/ebf47/image-9.png 688w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위 예제에서 <code>length</code> 필드가 그 예시입니다. 모든 인수에는 이름이 존재해요. 다른 언어의 함수처럼 인자 전달 순서대로 인자를 인식하는 것이 아니라 GraphQL의 모든 인자는 특별한 이름으로 전달되고 인식해요. 위 예제에서 <code>length</code> 필드는 하나의 인자 unit을 가지게 돼요.</p>\n<p>인자는 필수거나 옵셔널일 수 있어요. 인자가 옵셔널인 경우 기본값을 정의할 수 있어요.<br/>\n위 예제에서 unit 인자가 전달되지 않으면 기본적으로 METER로 설정돼요.</p>\n<hr>\n<h2>인트로스펙션</h2>\n<p>기존 서버-클라이언트 협업 방식에서는 API 명세서를 주고받는 절차가 반드시 필요했어요. 하지만 명세서 자체가 관리 대상이 되고, 프로젝트 관리 측면에서 관리해야 할 대상의 증가는 작업의 복잡성 및 효율성을 저해시킬 수 있죠. API 명세서는 때때로 관리가 제대로 되지 않거나, 공유가 되지 않아 문제가 발생하는 경우도 적지 않았어요.</p>\n<p>이러한 REST API 명세서 공유와 같은 문제를 해결하는 것이 GraphQL의 인트로스펙션 기능이에요. GraphQL의 인트로스펙션은 서버 자체에서 현재 서버에 정의된 스키마의 실시간 정보를 공유를 할 수 있게 하는 기능이에요. 이 스키마 정보만 알고 있으면 클라이언트 사이드에서는 따로 명세서를 요청 할 필요가 없게 되고, 스키마에 맞춰 쿼리문을 작성하면 됩니다.</p>\n<p>이러한 인트로스펙션에 사용하는 쿼리가 별도로 존재해요. 일반적인 GraphQL 쿼리문을 작성하듯이 작성하면 돼요.\n다만 실제로는 굳이 스키마 인트로스펙션을 위해 따로 쿼리문을 작성할 필요가 없어요. 대부분의 서버용 GraphQL 라이브러리에서 쿼리용 IDE를 제공하기 때문이에요.</p>\n<p>다음은 apollo server라는 서버용 GraphQL 라이브러리에 포함 되어있는 웹 IDE 화면입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.25766871165644%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC4UlEQVR42oWSTU8TYRDHe+DAgSCFQi193W23L7vdbrstS+kLEN5MTIwe9crBxItnD16NSkDLYvDgZ+BuEzkpFAyJL59AY0SkNRFa2u4+3Wec3TYo4eAk/8zMJvvLf2Yem8hxbDYtrs/mZ9XpuTl1bmFRTcqKyobCashSyKqjsZgqSZIqiaKVRSmpCoKAvbQuYZ1ISKVgMBiycRy3kJlQIJ2dATlbpOnJPAhSBoJREdhIHLNkaczNgisQgQAbAT8TxpoHv9kzYcpwPLgDYRgedS3ZuFhsIZUtGmxqmjCJgu5keOKNpokrLJNRJk7GQjK5Gk6R+w8ektWNV+RJ6SVZKW2Sx2svyNPnm2RlraQ/29gkj1bVzvLde0u2QRezOBqSwcmlYDySojdvL0MwWQAPPwnj/BS4IgqMxxXY+/wBzDAMw8pAKTY6Fh1qtrquw/b2dhfoZEUIxdPA8RP02o07wEgFCMjzwE7MgzdegOSt63Dw5ROQlg7NZhNarRacnNah1WxBhxCKAa12G8rlcs8hE0eHCRjx8nTIK4BbmAIPypvIYc5CMD8DlY97aKMFbfzRdNNonEHzrI4GNcuhpml/HToCcRj2o3w8vRpOIyQHbj6LY2fBHUUhdKfyFsfU0JFuTWw6+n3aANJu9ID/jDziF8CUCXSGUpY7C4ggd2wSPOh0dx+B7V+g1atdII7dbOug6aZDenGH/wdOwc5+xRpZq9eAdjQE6WDuzjzPpaP0gBSBBgIpAikCMWcpAqlHzNHd9+8odHSqn51RorWp0QWZMs9OzR2eHwVBuEMB7KZDTsbL5rpHieNx+O5xKgd7vWfT6b0aCr246PDKmG/ezSWokxEMhy/aGfZGjBFf1JLDjxl7BxszXr8pGye1mnH0/atx/OObcfzzyKhWq6Y6Nfx+eHhobG1tLdowBu12e35gaKjY3z9Q7OvrK9pslxUTxaKSyxVlpSdZQcnnymQyOUVRBv8AKm4r7ltIvPsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"apollo server graphql ide\"\n        title=\"\"\n        src=\"/static/a5ed2252af60faf39318743d654b6932/a6d36/image-10.png\"\n        srcset=\"/static/a5ed2252af60faf39318743d654b6932/222b7/image-10.png 163w,\n/static/a5ed2252af60faf39318743d654b6932/ff46a/image-10.png 325w,\n/static/a5ed2252af60faf39318743d654b6932/a6d36/image-10.png 650w,\n/static/a5ed2252af60faf39318743d654b6932/e548f/image-10.png 975w,\n/static/a5ed2252af60faf39318743d654b6932/3c492/image-10.png 1300w,\n/static/a5ed2252af60faf39318743d654b6932/d8ced/image-10.png 2652w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>개발자는 인트로스펙션을 활용하여, 직접 쿼리 및 뮤테이션, 필드 스키마를 확인할 수 있어요.<br/>\n상용환경에서는 보안상의 이슈로 이러한 스키마의 공개는 신중해야 해요. 대부분의 라이브러리는 해당 기능을 끄고 켜는 옵션이 존재해요.</p>\n<hr>\n<h2>GraphQL을 사용하는 기업</h2>\n<p>GraphQL 홈페이지 하단을 보면 GraphQL을 사용하는 기업 목록을 볼 수 있어요.<br/>\n유명한 기업들은 다음과 같다.</p>\n<p>• <strong>FaceBook</strong></p>\n<p>• <strong>Github</strong></p>\n<p>• <strong>Pinterest</strong></p>\n<p>• <strong>Twitter</strong></p>\n<p>이 중, Github는 API v3에서 REST 방식을 사용하다가 v4에서는 GraphQL로 갈아탔는데, 아래 링크의 글을 읽어보면 GraphQL의 장점을 확인할 수 있어요.</p>\n<p><a href=\"https://docs.github.com/ko/graphql\">https://docs.github.com/ko/graphql</a></p>\n<p>또, Github Explorer에서 GraphQL을 사용해볼 수 있도록 지원해주는데, 로그인 이후 본인의 계정 정보를 조회해볼 수 있어요.</p>\n<p><a href=\"https://docs.github.com/ko/graphql/overview/explorer\">https://docs.github.com/ko/graphql/overview/explorer</a></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.44171779141104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACOklEQVR42oWRyU9TURSHuwCjIND2dXhAB6YACRFdaOLCGOPCaOI/4MKFGmWhYIwyKEKpKEPQIFBwqwsExIa9xrhwCOpCSk0E4kK3gmIUKn1DP+99hYiEyEl+Offcd+6X837H5isqx5UfxO4qwOn143D7cKlBFG8QpyeAw+NfVcCq7W6/JVnLHk9BiZUVb5E4F2PL95fiL64g16myLcvOrj17efniGa9fPWfq/SRzs9PMzsQszXyc4tNcXNzFiMffEpua5EP8HdOxN3z5PEN9YwM2RQ2IiQIWcHuOi6rq3TwaizA83MvIwz5GR/sZGx1gZKSfYaHx6CATE/eIihx9LBQdYnw8wtMnDzhbcxKbr7icsspqchxeIQ9ZeSqHjp3gZs8QrR29tHX20dZxl1BXH+3Xewi33CbcPUB7d0RokBtdEcKdA9yJ3Gf/waPYCoPlBEoqLQ8d7gIysxUu1ocx0fm29JXFxHd+JBaZT8yzvLAAS0lWjBS6bgAGqVQKwzCRcabmArZgWRWB0gqxEB+K6hNAF7WXWzF0nZ+/ljFMQzyQ0knqGklNQ9N0AdStHlN800SWcfqcAEr/HO5Cdto95CkqGVkKdVdarYbfK+nGtZDTpExzwx2YpvEXKEFS0sM8JZ+MHU5rQhnmhsdr0P8C08vwrgJVMtdNaAif5C+tl7FJrQkb0sDzmwCFh5ea2lcnTLFVyA4JTS+l9l9grlC2XeXA4eM0NYeob2qh8VpoSzVcbaE5dIt9R07xB7MfTlKKoLR9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"github graphql\"\n        title=\"\"\n        src=\"/static/1f8380548566d2e47b9c3b4e8f2ca502/a6d36/image-11.png\"\n        srcset=\"/static/1f8380548566d2e47b9c3b4e8f2ca502/222b7/image-11.png 163w,\n/static/1f8380548566d2e47b9c3b4e8f2ca502/ff46a/image-11.png 325w,\n/static/1f8380548566d2e47b9c3b4e8f2ca502/a6d36/image-11.png 650w,\n/static/1f8380548566d2e47b9c3b4e8f2ca502/e548f/image-11.png 975w,\n/static/1f8380548566d2e47b9c3b4e8f2ca502/3c492/image-11.png 1300w,\n/static/1f8380548566d2e47b9c3b4e8f2ca502/09d8d/image-11.png 3012w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>다음과 같이 GraphQL 쿼리를 활용해서 로그인된 유저 닉네임을 조회하였고, 로그인한 저의 닉네임이 잘 표시되는 것을 확인할 수 있었어요.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"title":"GraphQL 톺아보기","desc":"GraphQL이 무엇인지 알아본 내용을 정리한 포스트입니다.","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABaklEQVR42pVTTVPCMBDNH3G4ASVUIf2AlBYRLIziVwXEo+NvcMajHpzx4viXn7tpM1NadPCws5tN9u1L9kVIb4SuH4N9R0UHmfTqOYshdg8SOJn8JyDXWULCJti7aoQW+ZbScL34V/AyoK21OcFU3SAxGw01gPZPEQcTNLyhyTsVMLOms46NK42ENBsaJ8RoFczxodf4jDZ4CBfoqxiK8rawzW/FjMiUl6BHezVA27XnJ3iLVrgMZkiDKd41x+fYEnAWpLgh21DM9jRcIhsssA7nGPsTNImQVPk7ClnQ5/f7ira4J5ZXBPQ9ekTiTUyDOTW4ptzzYEk+pYYzc+aW4guKO4VS+IkMICeOyfiarzrDi74zcVflzZgBe153yJp9nUuFatxiwtZEeVo8lCScYhye4agf1ibslCRiiVQVIMo64m7tQjY5m2gHlK/EV9uvzUKH1R8i/xC2rFxv3xlRKzrw+5Ub5APJv94PjZ+GcsEDg7wAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/5a356bf3b9d39326df24b99933c4057e/b918e/graphql.png","srcSet":"/static/5a356bf3b9d39326df24b99933c4057e/b918e/graphql.png 3979w","sizes":"3979px"},"sources":[{"srcSet":"/static/5a356bf3b9d39326df24b99933c4057e/f1e6e/graphql.webp 3979w","type":"image/webp","sizes":"3979px"}]},"width":3979,"height":2400}}},"date":"2024-04-24","category":"Dev"}}},"pageContext":{"slug":"/blog/GraphQL/"}},"staticQueryHashes":["1840460387"],"slicesMap":{}}